/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package uk.co.pentest.SHELLING;

import burp.BinaryPayloadIssue;
import burp.IBurpCollaboratorClientContext;
import burp.IBurpCollaboratorInteraction;
import burp.IScanIssue;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.swing.JFileChooser;
import javax.swing.JList;
import javax.swing.JOptionPane;

/**
 *
 * @author julian
 */
public class ShellingPanel2 extends javax.swing.JPanel {
    protected String byteGeneratorRange;           
    public String mode = "auto";
    public String targetOS = "all";
    public String feedbackChannel = "DNS"; // "DNS" is the other option atm (also planned: response (echo) and filesystem 
    public boolean scannerChecks = true; // whether to automatically extend the active scanning
    public int shellingLevel = 1; // 1 - minimum, 2 - medium, 3 - full, 0 - best effort payloads (not implemented yet)
    
    protected IntruderPayloadGenerator curr_generator;
    protected ArrayList<String> payloads;
    
    //public IntruderPayloadGenerator lastGenerator;
    // these need to  be public
    public static ArrayList<collabSession> collabSessions;      // 
    public static IBurpCollaboratorClientContext collabClient;  //	
        
    // We want to maintain this structure between the scans/intruder runs. The intention is as follows:    
    // 1. do not miss asynchronous injections, regardless to them being hit by scanner or intruder!
    // 2. thus, we can generate a new collabLoc for every single attack (active scan + intruder check).
    // 
    // The collabLoc will be used to match the collabSession, which in turn will contain more info about the attack (to reconstruct the valid request - we are definitely not going to store all the requests/responses in the memory for the puroose of tracking):
    // it would be, by the way, cool if Collaborator provided a nice way to use subdomains through collaborator API to track payloads
    // otherwise in order to identify a payload we have to assign a separate collabLoc per each one of them, which in our case might be way too many...?
    // I wonder how exactly Burp Scanner does it (match the right request) when using collaborator - cause it's capable of detecting asynchronous stuff, 
    // reverse lookups issued after hours pop up as External DNS interactions/OS command injections ;)
    
    // Per every single attack (Intruder attack/export/Active scan) - if auto mode is enabled - a new collabSession will be created and held until the plugin is unloaded:
    // timestamp of start
    // type of session (intruder/scanner/export)
    // configuration (so it should be easier to make sure we know where PAYLOAD_MARK points at)?
    // collabLoc - the ID generated by the Collaborator Server (the subdomain in burpcollaborator.net)
    // IHttpRequestResponse req - this will either contain the baseRequest provided to doActiveScan - or IIntruderAttack.getTemplateRequest() in case of Intruder, will be null for exports
    // what about including the shellings_raw payload set to it? this would make the payload matching accurate and should not be too mem-greey with reasonable configurations :D
    
    
    PrintWriter stdout;
    /**
     * Creates new form ShellingPanel2
     */
    public ShellingPanel2() 
    {      
        // activate the collaborator client
        this.collabClient = SHELLING.callbacks.createBurpCollaboratorClientContext();
        this.collabSessions = new ArrayList<collabSession>(); // consider providing the ability to reset this object if needed - another way to achieve this will be to reload the plugin
        
        // set extension output
        stdout = new PrintWriter(SHELLING.callbacks.getStdout(), true);
        
        // init the UI
        initComponents();                
        
        // enable "auto" mode for Intruder and export
        this.enableAuto();                                             
    }
    public int getDelay()
    {        
        return Integer.parseInt(this.delayTimeSpinner.getValue().toString());        
    }
    protected void appendListData(JList list, String[] items)
    {
        ArrayList tmp = new ArrayList();

         for (int i=0; i < list.getModel().getSize(); i++) {
            String elem = (String) list.getModel().getElementAt(i);           
            tmp.add(elem);
        }
        for(String item: items)
        {
            if(!tmp.contains(item)) tmp.add(item);
        }
        list.setListData(tmp.toArray());
    }
    private void removeFromListData(JList list, String item)
    {
        ArrayList tmp = new ArrayList();

         for (int i=0; i < list.getModel().getSize(); i++) {
            String elem = (String) list.getModel().getElementAt(i); 
            if(!elem.equals(item)) tmp.add(elem);
        }
        list.setListData(tmp.toArray());
    }
    private void initiateEncodings() // same as clear, no encoding by default
    {
        String empty[] = {"None"};
        encodeList.setListData(empty);
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        buttonGroup2 = new javax.swing.ButtonGroup();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        targetOSCombo = new javax.swing.JComboBox<>();
        jLabel4 = new javax.swing.JLabel();
        argumentField = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        commandField = new javax.swing.JTextField();
        payloadMarkingBox = new javax.swing.JCheckBox();
        scannerChecksBox = new javax.swing.JCheckBox();
        feedbackChannelCombo = new javax.swing.JComboBox<>();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        shellingLevelCombo = new javax.swing.JComboBox<>();
        delayTimeSpinner = new javax.swing.JSpinner();
        jLabel10 = new javax.swing.JLabel();
        manualModeCheckBox = new javax.swing.JCheckBox();
        jPanel5 = new javax.swing.JPanel();
        argInjectionCheckBox = new javax.swing.JCheckBox();
        onlyKnownArgInjections = new javax.swing.JRadioButton();
        bruteArgInjections = new javax.swing.JRadioButton();
        jPanel6 = new javax.swing.JPanel();
        jPanel2 = new javax.swing.JPanel();
        jLabel9 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        encodeList = new javax.swing.JList<>();
        encodingsToUse = new javax.swing.JComboBox<>();
        removeEncoding = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        useTerminatorsCheckBox = new javax.swing.JCheckBox();
        includeLiteralNullbytes = new javax.swing.JCheckBox();
        includeThePooComboBox = new javax.swing.JCheckBox();
        jPanel3 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        saveToFileButton = new javax.swing.JButton();
        saveToClipBoardButton = new javax.swing.JButton();
        jPanel4 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        byteGeneratorRangeCombo = new javax.swing.JComboBox<>();

        jLabel3.setText("Command to use");

        targetOSCombo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "All (default)", "Windows", "Nix" }));
        targetOSCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                targetOSComboActionPerformed(evt);
            }
        });

        jLabel4.setText("Target OS");

        argumentField.setText("PAYLOAD_MARK.BURPCOLLAB_DOMAIN");
        argumentField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                ShellingPanel2.this.keyReleased(evt);
            }
        });

        jLabel5.setText("Argument");

        commandField.setText("nslookup");

        payloadMarkingBox.setSelected(true);
        payloadMarkingBox.setText("Payload marking");
        payloadMarkingBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                payloadMarkingBoxActionPerformed(evt);
            }
        });

        scannerChecksBox.setSelected(true);
        scannerChecksBox.setText("Active scanning");
        scannerChecksBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                scannerChecksBoxActionPerformed(evt);
            }
        });

        feedbackChannelCombo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "DNS (collaborator)", "Delay (sleep)" }));
        feedbackChannelCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                feedbackChannelComboActionPerformed(evt);
            }
        });

        jLabel7.setText("Feedback channel");

        jLabel8.setText("SHELLING mode");

        shellingLevelCombo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Best effort payloads (default)", "Small set", "Moderate", "Full set" }));
        shellingLevelCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                shellingLevelComboActionPerformed(evt);
            }
        });

        delayTimeSpinner.setModel(new javax.swing.SpinnerNumberModel(25, 10, null, 1));
        delayTimeSpinner.setEnabled(false);
        delayTimeSpinner.setValue(25);

        jLabel10.setText("Delay [s]");

        manualModeCheckBox.setToolTipText("");
        manualModeCheckBox.setLabel("Manual (non-auto) mode for Intruder & export  (please refer the documentation for details)");
        manualModeCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                manualModeCheckBoxActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(manualModeCheckBox, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(jPanel1Layout.createSequentialGroup()
                                    .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 235, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGap(18, 18, 18)
                                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(targetOSCombo, javax.swing.GroupLayout.PREFERRED_SIZE, 292, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(commandField, javax.swing.GroupLayout.PREFERRED_SIZE, 297, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(argumentField, javax.swing.GroupLayout.PREFERRED_SIZE, 564, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGroup(jPanel1Layout.createSequentialGroup()
                                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                        .addComponent(jLabel7, javax.swing.GroupLayout.DEFAULT_SIZE, 374, Short.MAX_VALUE)
                                        .addComponent(jLabel8, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                    .addGap(32, 32, 32)
                                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                        .addComponent(feedbackChannelCombo, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(shellingLevelCombo, 0, 401, Short.MAX_VALUE))))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(payloadMarkingBox, javax.swing.GroupLayout.PREFERRED_SIZE, 307, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(107, 107, 107)
                                .addComponent(scannerChecksBox, javax.swing.GroupLayout.PREFERRED_SIZE, 330, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(81, 81, 81))
                            .addComponent(jLabel5, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 247, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(28, 28, 28)
                        .addComponent(jLabel10, javax.swing.GroupLayout.PREFERRED_SIZE, 138, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(delayTimeSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, 84, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 72, Short.MAX_VALUE)))
                .addContainerGap())
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel1Layout.createSequentialGroup()
                    .addGap(22, 22, 22)
                    .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 249, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(912, Short.MAX_VALUE)))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(9, 9, 9)
                .addComponent(targetOSCombo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(commandField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(argumentField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(payloadMarkingBox)
                    .addComponent(scannerChecksBox, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(8, 8, 8)
                .addComponent(manualModeCheckBox)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jLabel10, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(delayTimeSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(jLabel7, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(feedbackChannelCombo, javax.swing.GroupLayout.Alignment.LEADING)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel8, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(shellingLevelCombo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 197, Short.MAX_VALUE))
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel1Layout.createSequentialGroup()
                    .addGap(10, 10, 10)
                    .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(430, Short.MAX_VALUE)))
        );

        jTabbedPane1.addTab("Global settings", jPanel1);

        argInjectionCheckBox.setText("Attempt argument injection");
        argInjectionCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                argInjectionCheckBoxActionPerformed(evt);
            }
        });

        onlyKnownArgInjections.setText("Use popular OS-specific patterns");
        onlyKnownArgInjections.setEnabled(false);
        onlyKnownArgInjections.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                onlyKnownArgInjectionsActionPerformed(evt);
            }
        });

        bruteArgInjections.setText("Bruteforce the flags");
        bruteArgInjections.setEnabled(false);
        bruteArgInjections.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bruteArgInjectionsActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addGap(33, 33, 33)
                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(argInjectionCheckBox, javax.swing.GroupLayout.DEFAULT_SIZE, 388, Short.MAX_VALUE)
                        .addComponent(bruteArgInjections, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addComponent(onlyKnownArgInjections, javax.swing.GroupLayout.PREFERRED_SIZE, 476, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(674, Short.MAX_VALUE))
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(argInjectionCheckBox)
                .addGap(18, 18, 18)
                .addComponent(onlyKnownArgInjections)
                .addGap(18, 18, 18)
                .addComponent(bruteArgInjections)
                .addContainerGap(352, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Argument injection", jPanel5);

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1183, Short.MAX_VALUE)
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 475, Short.MAX_VALUE)
        );

        jTabbedPane1.addTab("Terminal injection", jPanel6);

        jLabel9.setText("Output encodings to use");

        encodeList.setModel(new javax.swing.AbstractListModel<String>() {
            String[] strings = { "None" };
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
        jScrollPane1.setViewportView(encodeList);

        encodingsToUse.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "None (default)", "URL", "Double URL" }));
        encodingsToUse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                encodingsToUseActionPerformed(evt);
            }
        });

        removeEncoding.setText("Remove");
        removeEncoding.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                removeEncodingActionPerformed(evt);
            }
        });

        jButton4.setText("Clear");
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        useTerminatorsCheckBox.setText("Include command terminators");
        useTerminatorsCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                useTerminatorsCheckBoxActionPerformed(evt);
            }
        });

        includeLiteralNullbytes.setText("Include literal nullbytes into the payload set (breaks GET and the clipboard)");
        includeLiteralNullbytes.setEnabled(false);

        includeThePooComboBox.setText("Include the 💩 (POO) character as terminator");
        includeThePooComboBox.setEnabled(false);

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 679, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(encodingsToUse, javax.swing.GroupLayout.PREFERRED_SIZE, 213, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(29, 29, 29)
                        .addComponent(removeEncoding, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(77, 77, 77)
                        .addComponent(jButton4, javax.swing.GroupLayout.PREFERRED_SIZE, 174, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(includeLiteralNullbytes, javax.swing.GroupLayout.PREFERRED_SIZE, 1159, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(useTerminatorsCheckBox, javax.swing.GroupLayout.PREFERRED_SIZE, 1095, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel9, javax.swing.GroupLayout.PREFERRED_SIZE, 706, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(includeThePooComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 637, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addComponent(jLabel9, javax.swing.GroupLayout.PREFERRED_SIZE, 36, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(encodingsToUse, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(removeEncoding)
                    .addComponent(jButton4))
                .addGap(18, 18, 18)
                .addComponent(useTerminatorsCheckBox)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(includeLiteralNullbytes, javax.swing.GroupLayout.PREFERRED_SIZE, 57, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(includeThePooComboBox)
                .addContainerGap(152, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Evasive techniques", jPanel2);

        jLabel2.setText("Instead of feeding the tools, save the result payload set:");

        saveToFileButton.setText("To file");
        saveToFileButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveToFileButtonActionPerformed(evt);
            }
        });

        saveToClipBoardButton.setText("To clipboard");
        saveToClipBoardButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveToClipBoardButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 932, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(saveToFileButton, javax.swing.GroupLayout.PREFERRED_SIZE, 213, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(31, 31, 31)
                        .addComponent(saveToClipBoardButton, javax.swing.GroupLayout.PREFERRED_SIZE, 213, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(239, Short.MAX_VALUE))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(saveToFileButton, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(saveToClipBoardButton, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(380, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Save the payloads", jPanel3);

        jLabel1.setText("Byte range");

        byteGeneratorRangeCombo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Non-numeric", "Alphanumeric", "Non-alphanumeric printable", "Non-alphanumeric non-printable", "Non-alphanumeric non-printable <128", "All" }));
        byteGeneratorRangeCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                byteGeneratorRangeComboActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 209, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(byteGeneratorRangeCombo, javax.swing.GroupLayout.PREFERRED_SIZE, 751, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(199, Short.MAX_VALUE))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(byteGeneratorRangeCombo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(420, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Byte generator", jPanel4);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane1)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTabbedPane1, javax.swing.GroupLayout.Alignment.TRAILING)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
        
        initiateEncodings();
    }//GEN-LAST:event_jButton4ActionPerformed

    private void targetOSComboActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_targetOSComboActionPerformed
        // TODO add your handling code here:
        switch(targetOSCombo.getSelectedIndex())
        { 
            case 0 : { this.targetOS="all"; break;}
            case 1 : { this.targetOS="win"; break;}
            case 2 : { this.targetOS="nix"; break;}
        }     
    }//GEN-LAST:event_targetOSComboActionPerformed

    private void feedbackChannelComboActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_feedbackChannelComboActionPerformed
       
        delayTimeSpinner.setEnabled(false);
        switch(feedbackChannelCombo.getSelectedIndex())
        { 
            case 0 : { this.feedbackChannel="DNS"; break;}
            case 1 : { this.feedbackChannel="time"; delayTimeSpinner.setEnabled(true); break;}  
            // case 2 : { this.feedbackChannel="filesystem"; break; } //
            // there also SHOULD be the 'echo' feedback channel supported
            // case 3 : { this.feedbackChannel="echo"; break; } // no asynchronous payload tracking
        }
    }//GEN-LAST:event_feedbackChannelComboActionPerformed
    private void updatePayloadMarkingHolder()
    {
        String dot="";
        if(this.feedbackChannel=="DNS")
        {
            dot=".";
        }
        if(payloadMarkingBox.isSelected()) 
        {//checkbox has been selected
            if(!this.argumentField.getText().contains("PAYLOAD_MARK"))
            {
                this.argumentField.setText("PAYLOAD_MARK"+dot+argumentField.getText()); 
            }                
        } 
        else
        {
            if(this.argumentField.getText().contains("PAYLOAD_MARK"))
            {
                this.argumentField.setText(argumentField.getText().replace("PAYLOAD_MARK"+dot,""));
            }
        }        
    }
    private void payloadMarkingBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_payloadMarkingBoxActionPerformed
       updatePayloadMarkingHolder();
    }//GEN-LAST:event_payloadMarkingBoxActionPerformed

    private void scannerChecksBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_scannerChecksBoxActionPerformed
        // TODO add your handling code here:
        if(scannerChecksBox.isSelected())
        {
            scannerChecks=true;
        }
        else
        {
            scannerChecks=false;
        }
    }//GEN-LAST:event_scannerChecksBoxActionPerformed

    private void removeEncodingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_removeEncodingActionPerformed
       
        if(encodeList.getSelectedIndex()!=-1) removeFromListData(encodeList,(String)encodeList.getModel().getElementAt(encodeList.getSelectedIndex()));                                
        if(encodeList.getModel().getSize()==0) this.initiateEncodings();
    }//GEN-LAST:event_removeEncodingActionPerformed

    private void encodingsToUseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_encodingsToUseActionPerformed
        
        switch(encodingsToUse.getSelectedIndex())
        { 
            case 0 : { 
                this.initiateEncodings(); break;
            }
            case 1 : { String n[]={"URL"}; appendListData(encodeList,n); break;}
            case 2 : { String n[]={"Double URL"}; appendListData(encodeList,n);  break;}
        }
    }//GEN-LAST:event_encodingsToUseActionPerformed

    private void byteGeneratorRangeComboActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_byteGeneratorRangeComboActionPerformed
        // TODO add your handling code here:
        switch (byteGeneratorRangeCombo.getSelectedIndex()) 
        {
            case 0:
            {
                this.byteGeneratorRange = "non-alpha";
                break;
            }
            case 1:
            {
                this.byteGeneratorRange = "alpha";           
                break;
            }
            case 2:
            {
                this.byteGeneratorRange = "non-alpha-print";
                break;
            }
            case 3:
            {
                this.byteGeneratorRange = "non-alpha-non-print";
                break;
            }
            case 4:
            {
                this.byteGeneratorRange = "non-alpha-non-print-low";
                break;
            }
            case 5:
            {
                this.byteGeneratorRange = "all";
                break;
            }
        }
    }//GEN-LAST:event_byteGeneratorRangeComboActionPerformed

    // this method simply runs a new payload generator, runs it and fills this.payloads with its results
    // used by save to file/copy to clipboard features
    protected void generatePayloads()
    {
        // now, for some reason this instance creation hangs burp
        IntruderPayloadGenerator generator = new IntruderPayloadGenerator("cmd", SHELLING.ShellingTab, "export", null);               
       // this.lastGenerator  = generator; // 
        payloads = new ArrayList();                
        while(generator.hasMorePayloads())
        {
            byte[] empty={};
            byte[] payload = generator.getNextPayload(empty); 
            // there is no insertion point for this option; the insertion point is the file/clipboard
            // hence the argument is empty, but could be the file name as well                  
            if(payload.length==1) 
            { //payload generation failed, move onto next command
		logOutput("Payload generation failed!");			                        
            }                                        
            payloads.add(SHELLING.callbacks.getHelpers().bytesToString(payload));
            // bytesToString                    
        }         
    }    
    
    private void saveToFileButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveToFileButtonActionPerformed
        // TODO add your handling code here:
                // save payloads to file
        JFileChooser fileChooser = new JFileChooser();
                     
        if (fileChooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) 
        {
            // new generator
            File file = fileChooser.getSelectedFile();
            logOutput("File chosen:"+file.getAbsolutePath());   
            
          //  this.generatePayloads();
            jTabbedPane1.setTitleAt(4,"Save "+payloads.size()+" payloads");

            logOutput("Generated "+payloads.size()+" payloads, saving..."); 
           
            BufferedWriter writer = null;
            try
            {
                writer = new BufferedWriter( new FileWriter(file.getAbsolutePath()));
                for(int i=0;i<payloads.size();i++)
                {
                    writer.write(payloads.get(i)+"\n"); // payloads with literals like newline characters will break this format, obviously (no such payloads in the set by default)
                }
            }
            catch (IOException e)
            {
                this.logOutput("IOException occurred while trying to open the file: "+file.getAbsolutePath());
            }
            finally
            {
                try
                {
                    if ( writer != null)
                    writer.close( );
                }
                catch ( IOException e)
                {
                    this.logOutput("IOException occurred while writing to the file: "+file.getAbsolutePath());
                }
            }           
        }
    }//GEN-LAST:event_saveToFileButtonActionPerformed

    private void saveToClipBoardButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveToClipBoardButtonActionPerformed
        // TODO add your handling code here:
        if(this.useTerminatorsCheckBox.isSelected()==true&&this.includeLiteralNullbytes.isSelected()==true)
        {
            JOptionPane.showMessageDialog(null, "Literal NULLBYTE terminators are enabled and this will most likely break the contents copied into the clipboard. To avoid this issue, save into a file instead or disable NULLBYTE terminators in evasive techniques.", "Payload set contains NULL bytes", JOptionPane.INFORMATION_MESSAGE);            
        }
        
        this.generatePayloads();
        jTabbedPane1.setTitleAt(4,"Save "+payloads.size()+" payloads");
        
        String clipboardS="";
        for(int i=0;i<payloads.size();i++)
        {
            clipboardS+=payloads.get(i)+"\n"; // payloads with literals like newline characters will break this format, obviously (no such payloads in the set by default)
        };
        
        StringSelection selection;
        selection = new StringSelection(clipboardS);
                
        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        clipboard.setContents(selection, selection);
    }//GEN-LAST:event_saveToClipBoardButtonActionPerformed

    private void useTerminatorsCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_useTerminatorsCheckBoxActionPerformed
        // TODO add your handling code here:
        if(useTerminatorsCheckBox.isSelected())
        {
            includeLiteralNullbytes.setEnabled(true);
            includeThePooComboBox.setEnabled(true);
        }
        else
        {
            includeLiteralNullbytes.setEnabled(false);
            includeThePooComboBox.setEnabled(false);
        }
    }//GEN-LAST:event_useTerminatorsCheckBoxActionPerformed

    private void keyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_keyReleased
        // TODO add your handling code here:
        if(argumentField.getText().matches("^\\d+.*$")&&this.mode=="manual")
        {
            JOptionPane.showMessageDialog(argumentField,"WARNING: It is NOT recommended to use arguments starting with numbers for nix targets (this WILL make all $IFS$9 payloads FAIL)!");
        }
    }//GEN-LAST:event_keyReleased

    private void argInjectionCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_argInjectionCheckBoxActionPerformed
        // TODO add your handling code here:
        if(argInjectionCheckBox.isSelected())
        {
            bruteArgInjections.setEnabled(true);
            onlyKnownArgInjections.setEnabled(true);            
        }
        else
        {
            bruteArgInjections.setEnabled(false);
            onlyKnownArgInjections.setEnabled(false);            
        }
    }//GEN-LAST:event_argInjectionCheckBoxActionPerformed

    private void onlyKnownArgInjectionsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_onlyKnownArgInjectionsActionPerformed
        // TODO add your handling code here:
        if(onlyKnownArgInjections.isSelected())
        {
            bruteArgInjections.setSelected(false);
        }
        else
        {
            bruteArgInjections.setSelected(true);
        }
    }//GEN-LAST:event_onlyKnownArgInjectionsActionPerformed

    private void bruteArgInjectionsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bruteArgInjectionsActionPerformed
        // TODO add your handling code here:
        if(bruteArgInjections.isSelected())
        {
            onlyKnownArgInjections.setSelected(false);
        }
        else
        {
            onlyKnownArgInjections.setSelected(true);
        }
    }//GEN-LAST:event_bruteArgInjectionsActionPerformed

    private void shellingLevelComboActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_shellingLevelComboActionPerformed
        // TODO add your handling code here:
        this.shellingLevel=shellingLevelCombo.getSelectedIndex();        
    }//GEN-LAST:event_shellingLevelComboActionPerformed

    private void manualModeCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_manualModeCheckBoxActionPerformed
        // TODO add your handling code here:
        if(manualModeCheckBox.isSelected())
        {            
            this.disableAuto();
        }
        else
        {
            this.enableAuto();
        }        
    }//GEN-LAST:event_manualModeCheckBoxActionPerformed
    private void disableAuto()
    {
        this.mode="manual";
        this.commandField.setEnabled(true);
        this.argumentField.setEnabled(true);
                
        this.payloadMarkingBox.setEnabled(true);
        this.feedbackChannelCombo.setEnabled(false);
        
        updatePayloadMarkingHolder();        
    }
    private void enableAuto()
    {
        this.mode="auto";
        this.commandField.setEnabled(false);
        this.argumentField.setEnabled(false);               
        this.feedbackChannelCombo.setSelectedIndex(0); // preferred, but not enforced setting
        
        this.payloadMarkingBox.setSelected(true);
        this.payloadMarkingBox.setEnabled(false);      // for all applicable feedback channels (currently only one supported)
        this.feedbackChannelCombo.setEnabled(true);
        
        updatePayloadMarkingHolder();
    }
    public void checkCollabInteractions()
    {
        logOutput("\n[+] Collaborator interaction check [this check runs even if the current mode is manual].");
        logOutput("[+] The number of tracked collab sessions is right now "+this.collabSessions.size());
        // only DNS interactions are supported at the moment
        // now, we decided to generate a unique burp collaborator ID per attack (this is simpler than an additional level of encapsulation in the payload itself, which is already way too long)
        // hence, we are going to fetch for all the interactions every time, one after another
        List<IScanIssue> report = null;
        List<IBurpCollaboratorInteraction> collabInter=null;
        Iterator<IBurpCollaboratorInteraction> collabInterItr;
        
        collabInter = this.collabClient.fetchAllCollaboratorInteractions();
        
        Map<String, ArrayList> validPayloads = new HashMap<String, ArrayList>();
                
        // validPayloads.get("collabId.burpcollaborator.net").add(";nslookup$IFS$9a23.collabId.burpcollaborator.net;"); // this is the expected result        

        // now we just iterate over all the interactions - and then search through our collabSessions
        if(collabInter.size()>0) 
        {                 
            //if interaction(s) were found from the current poll request, add all to overall list and continue
            collabInterItr = collabInter.iterator();
                
            report = new ArrayList<IScanIssue>();	
               
            IBurpCollaboratorInteraction inter;
            // OK, now we read all of them
            while(collabInterItr.hasNext())
            {            
                inter = collabInterItr.next();
                
                // This method is used to retrieve a property of the interaction. 
                // Properties of all interactions are: interaction_id, type, client_ip, and time_stamp. 
                // Properties of DNS interactions are: query_type and raw_query. The raw_query value is Base64-encoded. 
                // Properties of HTTP interactions are: protocol, request, and response. 
              
                // The request and response values are Base64-encoded
                logOutput("[+] Received a Collaborator interaction.");
                                
                // fuck, we're gonna have to match against the loc ourselves, it cannot be directly retrieved from the iterator!
                
                byte[] collabQuery = SHELLING.callbacks.getHelpers().base64Decode(inter.getProperty("raw_query"));
            
                // NOW, WHAT FOLLOWS IS THE UGLIEST SCULPTURE I HAVE EVER CODED:           
                // logOutput("[+] Raw query (base 64): "+inter.getProperty("raw_query"));
            
                String rawS = SHELLING.callbacks.getHelpers().bytesToString(collabQuery);
                logOutput("[+] Raw query (clear): "+rawS);
                byte[] trimed = new byte[collabQuery.length-16];
                for(int i=13;i<collabQuery.length-3;i++)
                {
                    trimed[i-13]=collabQuery[i];
                }
                String collabQueryS = SHELLING.callbacks.getHelpers().bytesToString(trimed);
                logOutput("[+] Trimed query: "+collabQueryS);   
                byte[] t = new byte[1];
                t[0]=(byte)0x1e; // Record Separator            
                String parts[] = collabQueryS.trim().split(SHELLING.callbacks.getHelpers().bytesToString(t));
                            
                    
                if(parts.length>1) // if there was a record (subdomain) in the hostname - which suggests the payload comes from our payload marking mechanisms, as I have not seen anyone else using this feature this way
                {
                    String payloadIndexS="0";
                    String pLoc="";
                    payloadIndexS=parts[0];                               
                    pLoc=parts[1];                    
                    String collabLocID = parts[1].substring(0,30);
                    
                    logOutput("[+] Payload index:"+payloadIndexS);
                    logOutput("[+] Collab location:"+collabLocID);
                                                            
                    if(payloadIndexS.startsWith("a")) payloadIndexS = payloadIndexS.replace("a",""); // we use markers starting with "a" when $IFS$9 is used
                    // we use $IFS$9 because we need to separate the IFS variable name from an argument
                    // otherwise ping$IFSlocalhost would not work ($IFSlocalhost would be taken as a bash variable)
                    // so we use $9 to separate $IFS from the argument, but for the same exact reason an argument starting with a digit (like a marked domain name, e.g. 4.<collabLoc>.burpcollaborator.net) would fail as well
                    // so we have to prepend the marker with an alphanumeric character ("a" was a good candidate) to solve the same problem

                    logOutput("[+] Searching for "+collabLocID+" in our sessions (iterating overall the whole set, starting with the most recent one)...");
                    
                    // we NEED to have a HashMap<collabID> with payloads that have worked for each single separate collabID
                    // there is no way to guarantee the order of the events coming
                    // and don't want to miss any if more are avaiable
                    // while not issuing duplicates either
                    
                    // so, we need to collect the feedback (the list of valid payloads) for every single recognized collabId separately, into a separate bucket
                    // and once all the collab interactions are processed, we pop the aggregated results by calling addScanIssue().
                    
                    boolean found=false;
                    ArrayList<String> payloads = new ArrayList<>(); // 
                    for(int i=this.collabSessions.size()-1;i>-1;i--)
                    {
                        logOutput("[+] Checking "+this.collabSessions.get(i).collabLoc+"...");
                        if(this.collabSessions.get(i).collabLoc.startsWith(collabLocID)) // match found!
                        {
                            found=true;
                            logOutput("[+] MATCH! We have a finding, sir!");                            
                            logOutput("[+] Payload was generated at "+this.collabSessions.get(i).getCreated()+" to feed the "+this.collabSessions.get(i).action);                            
                            /// we can also extract the payload if full payload tracking is on
                            // now, gather all the information required to pop this issue up using callbacks.addScanIssue()
                            int payloadIndex  = Integer.parseInt(payloadIndexS); 
                            payloadIndex-=1;    // payload marker was using arrays starting at 1... "I don't have strong opinions on anything" hehe
                            if(validPayloads.get(collabLocID)==null) // first entry, we have to create the object
                            {
                                logOutput("[+] Saved the interaction into a new bucket created for "+collabLocID+".");                            
                                ArrayList<String> arr = new ArrayList<String>(); 
                                // we are getting a null pointer here (getShellingsRaw(), because... well, this thing is filled AFTER the first exhaustion of all its payloads
                                // soo, if it's null, it means the payloads come from the current generator...
                                // so that last generator pointer was kinda useful 
                                // how about a pointer to the last payload set instead?
                                
                                // right, we have payloads for generatePayloads... not the same thing uh
                                if(this.collabSessions.get(i).getShellingsRaw()==null)
                                { // current payloads have not been propagated yet, the session is still ongoing
                                    // try to use curr_generator payloads instead                                    
                                    arr.add(this.curr_generator.shellings.get(payloadIndex));  
                                }
                                else
                                {
                                    arr.add(this.collabSessions.get(i).getShellingsRaw().get(payloadIndex));    
                                }                                                                    
                                logOutput("[+] Alive check");                                     
                                validPayloads.put(collabLocID,arr);
                                logOutput("[+] Running self check after creating an element (validPayloads).");
                                for (String key : validPayloads.keySet()) 
                                {
                                    logOutput("[+] validPayloads self check for the key "+key);
                                }
                                logOutput("[+] Selfcheck done. You should see at least one key above.");                                
                            }
                            else
                            {
                                if(this.collabSessions.get(i).getShellingsRaw()==null)
                                {
                                    validPayloads.get(collabLocID).add(this.curr_generator.shellings.get(payloadIndex));
                                }
                                else
                                {
                                    validPayloads.get(collabLocID).add(this.collabSessions.get(i).getShellingsRaw().get(payloadIndex));                                                                        
                                }
                                logOutput("[+] Added the interaction into an already existing bucket for "+collabLocID+".");                            
                            }
                            
                        }
                    }                  
                    if(!found) 
                    {
                        logOutput("[+] Could not match this interaction with any registered Collaborator session... Maybe the plugin was reloaded since the scan was initiated? Inspect manually.");                    
                        // in this case we also need to pop up a finding, this is too important to miss (again, an "unknown/unexpected collaborator interaction).
                    }
                    
                }                                                    
                else // no valid payload mark was spotted in the queried domain name
                {
                    // OK, at this point we are also getting here lookups that do NOT contain subdomains but are definitely matching
                    // we have to detect them (parse out the domain and match it with the sessions loc list) and silently ignore them if this is a pattern (dummy collaborator event)
                    for(int i=0;i<this.collabSessions.size();i++)
                    {
                        if(collabQueryS==this.collabSessions.get(i).collabLoc)
                        {
                            logOutput("Seems like a dummy session for "+collabQueryS+", this warning will be supressed in the future if proven to only accompany actual finding events (lookups with the correct payload mark) that are reported and recognized.");   
                            // this should, however, only be supressed if we already hit issues for this particular collabLoc (just create an array of strings and push the locs if issues were raised or sth)
                            //
                        }
                        else
                        {
                            logOutput("Query not recognized as originating from SHELLING! Please investigate manually.\n"); // these, in turn, should be used to create a separate scanner issue - just to avoid staying unnoticed (hey, we received some weird collaborator event)
                        }
                    }
                    
                }            
            }
            
            for (String key : validPayloads.keySet()) 
            {
                ArrayList<String> payloads = validPayloads.get(key);                
                if(payloads.size()==0)
                {
                    logOutput("[+] ERROR: An empty payload bucket encountered for "+key+"! This should never happen!");
                }
                else
                {
                    boolean found=false;
                    for(int i=0;i<this.collabSessions.size();i++)
                    {                        
                        logOutput("Comparing "+key+" with "+this.collabSessions.get(i).collabLoc+".");                
                        if(key.equals(this.collabSessions.get(i).collabLoc))
                        {
                            found=true;
                            // grab the details (collabLocId, created at, reported at at (current time)
                            logOutput("[+] The "+key+" payload bucket has been found, a new Scanner issue incoming!");
                            String details = "A potential OS command injection was detected using DNS as the feedback channel.\n";
                            details+="This finding was captured from a collabortor DNS interaction (session "+key+") initiated at "+  this.collabSessions.get(i).getCreated()+" for the following tool:"+this.collabSessions.get(i).action+".<br>";
                        
                            // we can actually try to attempt to use current generator to establish this, if possible
                            // interactinos caught later will not have the insertion point identified unless we start tracking that somehow too, without killing the memory
                            // assemble all the payloads into one description
                            String payloadsList="The following payloads successfully penetrated the input:<ul>";
                            for(int j=0;j<payloads.size();j++)
                            {
                                payloadsList+="<li>"+payloads.get(j)+"</li>"; // we should find a more optimum way, like a join("\n")                            
                                // also, might be a good idea to ship the payload index too - payloads with white/non-printable literals might be hard to identify
                            }
                            details+=payloadsList+"</ul><br>";
                        
                            if(this.collabSessions.get(i).baseReqRes==null)
                            {
                                details+="Please keep in mind this tracking session was created for a payload export session, hence Burp is not able to provide the vulnerable request, as it came from an external client instead of Scanner/Intruder.<br>";
                            }
                            else
                            {                            
                                details+="Please keep in mind that the provided HTTP request is the BASE request (the one sent to Scanner/Intruder), NOT the actually vulnerable request (the insertion point is not known).<br>"; // which sucks badly
                            }
                            // grab the baseReqResp
                            logOutput("[+] Adding a new Scan Issue, baby!");
                            SHELLING.callbacks.addScanIssue(new BinaryPayloadIssue(SHELLING.callbacks,this.collabSessions.get(i).baseReqRes,details));                                                
                            // add it
                            break; // from this loop
                        }
                    }
                    if(!found) logOutput("[+] ERROR! Weird, no matching sessions were found for "+key+"... This should never happen.");    
                }
                
            }                       
        }               
    } // end of the method
    
    protected int collabSessionID(String collabLocation)
    {        
        for(int i=this.collabSessions.size()-1;i>-1;i--)
        {
            if(this.collabSessions.get(i).collabLoc==collabLocation)
            {
                return i;
            }
        }
        return -1;
    }
    public void logOutput(String msg)
    {
        //this.logOutput.append(msg);
        stdout.println(msg);
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox argInjectionCheckBox;
    protected javax.swing.JTextField argumentField;
    private javax.swing.JRadioButton bruteArgInjections;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.ButtonGroup buttonGroup2;
    protected javax.swing.JComboBox<String> byteGeneratorRangeCombo;
    protected javax.swing.JTextField commandField;
    private javax.swing.JSpinner delayTimeSpinner;
    protected javax.swing.JList<String> encodeList;
    private javax.swing.JComboBox<String> encodingsToUse;
    protected javax.swing.JComboBox<String> feedbackChannelCombo;
    private javax.swing.JCheckBox includeLiteralNullbytes;
    public javax.swing.JCheckBox includeThePooComboBox;
    private javax.swing.JButton jButton4;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JCheckBox manualModeCheckBox;
    private javax.swing.JRadioButton onlyKnownArgInjections;
    public javax.swing.JCheckBox payloadMarkingBox;
    private javax.swing.JButton removeEncoding;
    private javax.swing.JButton saveToClipBoardButton;
    private javax.swing.JButton saveToFileButton;
    protected javax.swing.JCheckBox scannerChecksBox;
    protected javax.swing.JComboBox<String> shellingLevelCombo;
    protected javax.swing.JComboBox<String> targetOSCombo;
    private javax.swing.JCheckBox useTerminatorsCheckBox;
    // End of variables declaration//GEN-END:variables
}
